<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>LHCb Starterkit: First steps in LHCb</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css" />
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
     ga('create', 'UA-63818884-1', 'auto');
     ga('send', 'pageview');
    </script>
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="https://lhcb.github.io/first-analysis-steps/">
          <img src="img/new_starterkit.png" height="150" alt="LHCb Starterkit">
        </a>
      </div>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
          <h1 class="title">First steps in LHCb</h1>
          <h2 class="subtitle">Fun with LoKi Functors</h2>
<div id="learning-objectives" class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="learning-objectives" class="objectives panel panel-warning"><span class="glyphicon glyphicon-certificate"></span>Learning Objectives</h2>
</div>
<div class="panel-body">
<ul>
<li>Understand what LoKi functors are</li>
<li>Use LoKi functors interactively</li>
<li>Be able to find functors that do what we want</li>
</ul>
</div>
</div>
<p>LoKi functors are designed to flexibly compute and compare properties of the current decay, from simple quantities such as the transverse momentum of a particle to complicated ones like helicity angles. Internally, functors are implemented as C++ classes that take an object of type <code>TYPE1</code> and return another of <code>TYPE2</code>. They can be used both in C++ and in Python code, and can be combined with each other using logical operations.</p>
<p>According to <code>TYPE2</code> there are 3 types of functors:</p>
<ul>
<li><em>Functions</em>, which return <code>double</code>.</li>
<li><em>Predicates</em>, which return a <code>bool</code>.</li>
<li><em>Streamers</em>, which return a <code>std::vector</code> of some other type <code>TYPE3</code>.</li>
</ul>
<p>When filling tuples, the most used functors are functions, while predicates are typically used for selections.</p>
<p>According to <code>TYPE1</code>, there are many types of functors, the most important of which are (you can find a full list in the <a href="https://twiki.cern.ch/twiki/bin/view/LHCb/FAQ/LoKiFAQ#How_to_code_own_LoKi_functor">LoKi FAQ</a>):</p>
<ul>
<li><em>Particle functors</em>, which take <code>LHCb::Particle*</code> as input.</li>
<li><em>Vertex functors</em>, which take <code>LHCb::VertexBase*</code> as input.</li>
<li><em>MC particle functors</em>, which take <code>LHCb::MCParticle*</code> as input.</li>
<li><em>MC vertex functors</em>, which take <code>LHCb::MCVertex*</code> as input.</li>
<li><em>Array particle functors</em>, which take a <code>LoKi::Range_</code> (an array of particles) as input.</li>
<li><em>Track functors</em>, which take <code>LHCb::Track</code> as input.</li>
</ul>
<div id="c-classes" class="callout panel panel-info">
<div class="panel-heading">
<h2 id="c-classes" class="callout panel panel-info"><span class="glyphicon glyphicon-pushpin"></span>C++ classes</h2>
</div>
<div class="panel-body">
<p>Things like <code>LHCb::Particle</code> are C++ classes that usually represent some physical object. You will interact with the C++ objects directly very rarely, if ever.</p>
</div>
</div>
<p>To understand what we can do with LoKi functors, we will pick up from where we left off <a href="interactive-dst.html">exploring a DST interactively</a>. Open the DST and get the first candidate in the <code>D2hhCompleteEventPromptDst2D2RS</code> line:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cands <span class="op">=</span> evt[<span class="st">&#39;/Event/AllStreams/Phys/D2hhCompleteEventPromptDst2D2RSLine/Particles&#39;</span>]
cand <span class="op">=</span> cands[<span class="dv">0</span>]</code></pre></div>
<p>We can now try to get very simple properties of the <span class="math inline">\(D^{*+}\)</span> candidate, such as its transverse momentum and measured mass.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> PT, M
<span class="bu">print</span> PT(cand)
<span class="bu">print</span> M(cand)</code></pre></div>
<p>You will see an error when loading the functors:</p>
<pre><code>LoKiSvc.REPORT      ERROR LoKi::AuxDesktopBase:     loadDesktop(): unable to load IPhysDesktop! StatusCode=FAILURE
LoKiSvc.REPORT      ERROR The   ERROR message is suppressed : &#39;LoKi::AuxDesktopBase:    loadDesktop(): unable to load IPhysDesktop!&#39; StatusCode=FAILURE</code></pre>
<p>This is related to the fact that some functors need to run in the <code>DaVinci</code> ‘scope’, and they are all loaded in the <code>LoKiPhys.decorators</code> module. It's harmless in the examples we will use. If the import is made <em>before</em> the instantiation of the <code>ApplicationMgr</code>, there will be no warnings.</p>
<p>Math operations are also allowed:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> PX, PY, PZ
p_components_sum <span class="op">=</span> PX <span class="op">+</span> PY <span class="op">+</span> PZ
p_components_sum(cand)</code></pre></div>
<div id="does-it-make-sense" class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="does-it-make-sense" class="challenge panel panel-success"><span class="glyphicon glyphicon-pencil"></span>Does it make sense?</h2>
</div>
<div class="panel-body">
<p>Retrieve the momentum magnitude <span class="math inline">\(p\)</span> and see if you can get the same answer with the <code>PX</code>, <code>PY</code>, <code>PZ</code> functors. Also compute the invariant mass <span class="math inline">\(m\)</span> and see if it matches what the <code>M</code> functor returned.</p>
</div>
</div>
<p>If we want to get the properties of the <span class="math inline">\(D^{*+}\)</span> vertex, for example its fit quality (<span class="math inline">\(\chi^2\)</span>), we need to pass an object to the functor.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> VCHI2
<span class="bu">print</span> VCHI2(cand.endVertex())</code></pre></div>
<p>This is inconvenient when <a href="minimal-dv-job.html">running DaVinci with Python options files</a>, since in that case we don't have any way of calling the <code>endVertex</code> method. Instead, we can use the <code>VFASPF</code> <em>adaptor</em> functor, which allows us to use vertex functors as if they were particle functors (note how the functor is built by combining two functors).</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> VFASPF
VCHI2(cand.endVertex()) <span class="op">==</span> VFASPF(VCHI2)(cand)</code></pre></div>
<div id="functions-of-functions-of-functions-of" class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="functions-of-functions-of-functions-of" class="challenge panel panel-success"><span class="glyphicon glyphicon-pencil"></span>Functions of functions of functions of…</h2>
</div>
<div class="panel-body">
<p>Make sure you understand what <code>VFASPF(VCHI2)(cand)</code> means. It may help to play around in Python, creating a function that takes another function as an argument, for example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> create_greeting(salutation):
    <span class="kw">def</span> greet(name):
        <span class="bu">print</span> <span class="st">&#39;</span><span class="sc">{0}</span><span class="st">, </span><span class="sc">{1}</span><span class="st">!&#39;</span>.<span class="bu">format</span>(salutation, name)
    <span class="cf">return</span> greet</code></pre></div>
<p>What would <code>create_greeting('Hello')</code> return? What about <code>create_greeting('Howdy')('partner')</code>? Why is doing this useful?</p>
</div>
</div>
<p>The calculation of some of the properties, such as the impact parameter (IP) or direction angle (DIRA), require the knowledge of the primary vertex (PV) associated to the candidate. In <code>GaudiPython</code>, we can get the PVs ourselves.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pv_finder_tool <span class="op">=</span> appMgr.toolsvc().create(
    <span class="st">&#39;GenericParticle2PVRelator&lt;_p2PVWithIPChi2, OfflineDistanceCalculatorName&gt;/P2PVWithIPChi2&#39;</span>,
    interface<span class="op">=</span><span class="st">&#39;IRelatedPVFinder&#39;</span>
)
pvs <span class="op">=</span> evt[<span class="st">&#39;/Event/AllStreams/Rec/Vertex/Primary&#39;</span>]
best_pv <span class="op">=</span> pv_finder_tool.relatedPV(cand, pvs)
<span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> DIRA
<span class="bu">print</span> DIRA(best_pv)(cand)</code></pre></div>
<p>Given that this is a very common operation, we have the possibility of using, in the context of a <code>DaVinci</code> application (Stripping, for example), a special set of functors, starting with the <code>BPV</code> prefix (for Best PV), which will get the PV for us. Some functors also end with the suffix <code>DV</code>, which means they can only be used in the <code>DaVinci</code> context.</p>
<div id="finding-loki-functors" class="callout panel panel-info">
<div class="panel-heading">
<h2 id="finding-loki-functors" class="callout panel panel-info"><span class="glyphicon glyphicon-pushpin"></span>Finding LoKi functors</h2>
</div>
<div class="panel-body">
<p>The full list of defined LoKi functors can be found in the <code>LoKi::Cuts</code> namespace in the <a href="http://lhcb-release-area.web.cern.ch/LHCb-release-area/DOC/davinci/latest_doxygen/d7/dae/namespace_lo_ki_1_1_cuts.html">doxygen</a>. They are quite well documented with examples on how to use them. The list can be overwhelming, so it's also worth checking a more curated selection of functors in the TWiki, <a href="https://twiki.cern.ch/twiki/bin/view/LHCb/LoKiHybridFilters">here</a> and <a href="https://twiki.cern.ch/twiki/bin/view/LHCb/LoKiParticleFunctions">here</a>.</p>
</div>
</div>
<p>So far we've only looked at the properties of the head of the decay (that is, the <span class="math inline">\(D^{*+}\)</span>), but what if we want to get information about its daughters? As an example, let's get the largest transverse momentum of the final state particles. A simple solution would be to navigate the tree and calculate the maximum <span class="math inline">\(p_{\text{T}}\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> find_tracks(particle):
    tracks <span class="op">=</span> []
    <span class="cf">if</span> particle.isBasicParticle():
        proto <span class="op">=</span> particle.proto()
        <span class="cf">if</span> proto:
            track <span class="op">=</span> proto.track()
            <span class="cf">if</span> track:
                <span class="cf">try</span>:
                    tracks.append(particle.data())
                <span class="cf">except</span> <span class="pp">AttributeError</span>:
                    tracks.append(particle)
    <span class="cf">else</span>:
        <span class="cf">for</span> child <span class="kw">in</span> particle.daughters():
            tracks.extend(find_tracks(child))
    <span class="cf">return</span> tracks

max_pt <span class="op">=</span> <span class="bu">max</span>([PT(child) <span class="cf">for</span> child <span class="kw">in</span> find_tracks(cand)])</code></pre></div>
<div id="a-note-about-the-tryexcept" class="callout panel panel-info">
<div class="panel-heading">
<h2 id="a-note-about-the-tryexcept" class="callout panel panel-info"><span class="glyphicon glyphicon-pushpin"></span>A note about the try/except</h2>
</div>
<div class="panel-body">
<p>If you import LoKi before running this example, it magically removes the <code>.data()</code> function and allows the particle to be used directly. The code above is made general using the <code>try</code>/<code>except</code> block and will work in either case.</p>
</div>
</div>
<p>However, LoKi offers functions for performing such operations, namely <code>MAXTREE</code> and <code>MINTREE</code>, which get as parameters the selection criteria, the functor to calculate and a default value. In our example,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> MAXTREE, ISBASIC, HASTRACK
MAXTREE(ISBASIC <span class="op">&amp;</span> HASTRACK, PT, <span class="op">-</span><span class="dv">1</span>)(cand) <span class="op">==</span> max_pt</code></pre></div>
<p>In this example, we have used two selection functors, <code>ISBASIC</code> and <code>HASTRACK</code>, which return true if the particle doesn't have children and is made up by a track, respectively. We can see that they do the same thing as <code>particle.isBasicParticle()</code> and <code>particle.proto().track()</code> in a more compact way.</p>
<div id="combining-loki-cuts" class="callout panel panel-info">
<div class="panel-heading">
<h2 id="combining-loki-cuts" class="callout panel panel-info"><span class="glyphicon glyphicon-pushpin"></span>Combining LoKi cuts</h2>
</div>
<div class="panel-body">
<p>You might have noticed above we used the <code>&amp;</code> operator (&quot;bitwise AND&quot;) to combine the <code>ISBASIC</code> and <code>HASTRACK</code> cuts above. This is because Python doesn't allow LoKi to override the behaviour of <code>and</code> and <code>or</code> (&quot;logical AND/OR&quot;), so if we use them the Python interpreter tries to combine the two cuts straight away, before we have even passed in our candidate:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">In [<span class="dv">1</span>]: ((M<span class="op">&gt;</span><span class="dv">1200</span>) <span class="kw">or</span> (PT <span class="op">&gt;</span> <span class="dv">500</span>))
Out[<span class="dv">1</span>]:  (M<span class="op">&gt;</span><span class="dv">1200</span>)</code></pre></div>
<p>the result is that our <code>PT</code> cut vanishes! If we use the <code>|</code> operator (&quot;bitwise OR&quot;) then LoKi correctly builds a functor representing the <code>OR</code> of our cuts:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">In [<span class="dv">2</span>]: ((M<span class="op">&gt;</span><span class="dv">1200</span>) <span class="op">|</span> (PT <span class="op">&gt;</span> <span class="dv">500</span>))
Out[<span class="dv">2</span>]:  ( (M<span class="op">&gt;</span><span class="dv">1200</span>) <span class="op">||</span> (PT<span class="op">&gt;</span><span class="dv">500</span>) )</code></pre></div>
<p>This is why you should <strong>always</strong> use <code>&amp;</code> and <code>|</code> when combining LoKi functors, and <strong>never</strong> use <code>and</code> and <code>or</code>.</p>
</div>
</div>
<p>Similarly, the <code>SUMTREE</code> functor allows us to accumulate quantities for those children that pass a certain selection:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> SUMTREE, ABSID
<span class="bu">print</span> SUMTREE(<span class="dv">211</span> <span class="op">==</span> ABSID, PT)(cand)
<span class="bu">print</span> SUMTREE(<span class="st">&#39;pi+&#39;</span> <span class="op">==</span> ABSID, PT)(cand)</code></pre></div>
<p>In this case, we have summed the transverse momentum of the charged pions in the tree. Note the usage of the <code>ABSID</code> functor, which selects particles from the decay tree using either their <a href="http://pdg.lbl.gov/2015/mcdata/mc_particle_id_contents.html">PDG Monte Carlo ID</a> or their name.</p>
<p>Another very useful LoKi functor is <code>CHILD</code>, which allows us to access a property of a single children of the particle. To specify which child we want, its order is used, so we need to know how the candidate was built. For example, from</p>
<pre class="output"><code>In [10]: cand.daughtersVector()
Out[10]:

 0 |-&gt;D0                           M/PT/E/PX/PY/PZ: 1.8624/ 6.4521/ 47.44/-4.939/-4.152/ 46.96 [GeV]  #  0
                                       EndVertex  X/Y/Z:0.2911/-0.2378/-14.38 [mm]  Chi2/nDoF 0.4039/1 #  0
 1    |-&gt;K-                        M/PT/E/PX/PY/PZ: 0.4937/ 2.8013/ 25.45/-1.799/-2.147/ 25.29 [GeV]  # 19
 1    |-&gt;pi+                       M/PT/E/PX/PY/PZ: 0.1396/ 3.7258/ 21.99/-3.141/-2.004/ 21.67 [GeV]  # 22
 0 |-&gt;pi+                          M/PT/E/PX/PY/PZ: 0.1396/ 0.3701/ 2.678/-0.2873/-0.2333/ 2.649 [GeV]  # 10</code></pre>
<p>we know that <code>D0</code> is the first child and <code>pi+</code> is the second. Therefore, to access the <span class="math inline">\(p_{\text{T}}\)</span> of the <span class="math inline">\(D^{0}\)</span> we have 2 options.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiPhys.decorators <span class="im">import</span> CHILD
<span class="co"># Option 1</span>
mass <span class="op">=</span> M(cand.daughtersVector()[<span class="dv">0</span>])
<span class="co"># Option 2</span>
mass_child <span class="op">=</span> CHILD(M, <span class="dv">1</span>)(cand)
<span class="co"># Do they agree?</span>
mass <span class="op">==</span> mass_child</code></pre></div>
<p>The usage of LoKi functors extends much further than in the interactive <code>GaudiPython</code> world we've been exploring here.</p>
<p>They constitute the basis of particle filtering in the <em>selection framework</em>, discussed in the <a href="https://lhcb.github.io/second-analysis-steps/06-building-decays.html">Building your own decay chain</a> lesson in <a href="https://lhcb.github.io/second-analysis-steps/">second-analysis-steps</a>. Selecting particles means using LoKi <em>predicates</em>, functors that give a <code>bool</code> output, like <code>ISBASIC</code> and <code>HASTRACK</code>. Amongst these, a key functor is <code>in_range</code>, which returns <code>True</code> if the value of the given <em>function</em> functor (that is, the functor that returns a <code>double</code>) is within the given lower and upper limit. It helps writing CPU-efficient functors and thus is very important when building time-critical software like trigger or stripping lines.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiCore.functions <span class="im">import</span> in_range
in_range(<span class="dv">2000</span>, M, <span class="dv">2014</span>)(cand)
in_range(<span class="dv">1860</span>, CHILD(M, <span class="dv">1</span>), <span class="dv">1870</span>)(cand)</code></pre></div>
<p>Additionally, LoKi functors can be used directly inside our <code>DaVinci</code> jobs to store specific bits of information in our ntuples without the need for a complicated C++-based algorithms. This second option will be discussed in the <a href="add-tupletools.html">TupleTools and branches lesson</a>.</p>
<div id="debugging-loki-functors" class="callout panel panel-info">
<div class="panel-heading">
<h2 id="debugging-loki-functors" class="callout panel panel-info"><span class="glyphicon glyphicon-pushpin"></span>Debugging LoKi functors</h2>
</div>
<div class="panel-body">
<p>If you write complicated LoKi functors, typically in the context of selections, you need functions for debugging when things go wrong. LoKi provides wrapper functors that evaluate a functor (or functor expression), print debugging information and return the result; the most important of these are:</p>
<ul>
<li><p><code>dump1</code>, which prints the input object and returns the calculated functor value,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiCore.functions <span class="im">import</span> dump1
debug_p_components_sum <span class="op">=</span> dump1(p_components_sum)
debug_p_components_sum(cand)</code></pre></div></li>
<li><p><code>monitor</code> which prints the input the functor string and returns the calculated functor value,</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> LoKiCore.functions <span class="im">import</span> monitor
monitor_p_components_sum <span class="op">=</span> monitor(p_components_sum)
monitor_p_components_sum(cand)</code></pre></div></li>
</ul>
</div>
</div>
        </div>
      </div>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/lhcb/first-analysis-steps">Source</a>
        <a class="label swc-blue-bg" href="mailto:lhcb-starterkit@cern.ch">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/contrib/auto-render.min.js"></script>
    <script>
      // Go KaTeX go!
      renderMathInElement(document.body);
    </script>
  </body>
</html>
